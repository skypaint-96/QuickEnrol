name: CI & Release

on:
  push:         # every branch, incl. main
    branches: ["**"]
  pull_request:
    branches: ["**"]

jobs:
# ─────────────────────────── Build & Test ───────────────────────────
  build:
    runs-on: windows-latest
    steps:
      # full clone so NBGV sees the whole commit graph
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      # Calculate version + export env vars
      - uses: dotnet/nbgv@v0.4.2
        id: nbgv
        with:
          setAllVars: true

      # Dynamic project detection and publishing
      - name: Detect and publish projects
        id: projects
        shell: pwsh
        run: |
          # Find all publishable projects (exclude test projects)
          $publishableProjects = Get-ChildItem -Recurse -Filter *.csproj | 
                                Where-Object { 
                                  $content = Get-Content $_ -Raw
                                  -not ($content -match '<IsTestProject>true</IsTestProject>') -and
                                  -not ($_.FullName -match '\\tests\\' -or $_.FullName -match '/tests/')
                                }
          
          if (-not $publishableProjects) {
            Write-Error "No publishable projects found!"
            exit 1
          }
          
          $projectPaths = @()
          $projectNames = @()
          
          foreach ($proj in $publishableProjects) {
            $name = [System.IO.Path]::GetFileNameWithoutExtension($proj.Name)
            $path = $proj.FullName
            
            Write-Host "Publishing project: $name from $path"
            
            # Build and publish the project
            dotnet publish "$path" -c Release -o "./publish/$name"
            
            # Upload as artifact
            Write-Host "Creating artifact for $name"
            
            # Add to our arrays
            $projectPaths += $path
            $projectNames += $name
          }
          
          # Output as JSON arrays for later steps
          $pathsJson = ConvertTo-Json -InputObject $projectPaths -Compress
          $namesJson = ConvertTo-Json -InputObject $projectNames -Compress
          
          # Set outputs
          "paths=$pathsJson" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "names=$namesJson" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "count=$($projectNames.Count)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Restore
        run: dotnet restore

      - name: Build
        run: dotnet build --configuration Release --no-restore

      - name: Test
        run: dotnet test --configuration Release --no-build --verbosity normal

      # Upload artifacts (done in parallel for each project)
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: all-artifacts
          path: ./publish/**/*
          if-no-files-found: error

    # expose the SemVer and project info to the next job
    outputs:
      version: ${{ steps.nbgv.outputs.SemVer2 }}
      project_names: ${{ steps.projects.outputs.names }}
      project_count: ${{ steps.projects.outputs.count }}

# ───────────────────────────── Release ──────────────────────────────
  release:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: all-artifacts
          path: ./publish

      - name: Create zip archives
        id: create_zips
        shell: bash
        run: |
          # Parse the JSON array of project names
          PROJECT_NAMES=$(echo '${{ needs.build.outputs.project_names }}' | jq -r '.[]')
          ZIP_FILES=""
          
          # Create a zip for each project
          for project in $PROJECT_NAMES; do
            echo "Creating zip for $project"
            zip_name="${project}-v${{ needs.build.outputs.version }}.zip"
            zip -r "$zip_name" "./publish/$project"
            ZIP_FILES="${ZIP_FILES}${zip_name}\n"
          done
          
          # Store the list of zip files for the release
          echo "ZIP_FILES<<EOF" >> $GITHUB_ENV
          echo -e "$ZIP_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.build.outputs.version }}
          name: Release v${{ needs.build.outputs.version }}
          generate_release_notes: true
          files: ${{ env.ZIP_FILES }}